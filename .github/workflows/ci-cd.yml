name: Full Infra + App Deployment (Automated AKS + ACR)

on:
  push:
    branches: ["main"]

env:
  TF_VAR_location: "eastus"
  TF_VAR_resource_group_name: "rg-chandru-ecomm"
  TF_VAR_node_vm_size: "Standard_DS2_v2"
  TF_LOG: INFO

jobs:

####################################################################################
# 1) Stage: Terraform Infra Creation
####################################################################################
  terraform-infra:
    name: 1️⃣ Provision Infrastructure (Terraform)
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    outputs:
      acr_login_server: ${{ steps.out.outputs.acr_login_server }}
      acr_name: ${{ steps.out.outputs.acr_name }}
      aks_name: ${{ steps.out.outputs.aks_name }}
      resource_group: ${{ steps.out.outputs.resource_group }}

    steps:

    - name: Checkout
      uses: actions/checkout@v4

    - name: Azure Login (OIDC)
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Create Storage Backend
      run: |
        RESOURCE_GROUP=${{ env.TF_VAR_resource_group_name }}
        STORAGE="tf${GITHUB_RUN_ID}state"
        STORAGE=$(echo $STORAGE | tr -cd '[:alnum:]' | tr '[:upper:]' '[:lower:]')
        CONTAINER="tfstate"

        az group create -n $RESOURCE_GROUP -l ${{ env.TF_VAR_location }} --only-show-errors
        az storage account create -n $STORAGE -g $RESOURCE_GROUP -l ${{ env.TF_VAR_location }} --sku Standard_LRS
        az storage container create --name $CONTAINER --account-name $STORAGE

        echo "STORAGE=$STORAGE" >> $GITHUB_ENV
        echo "CONTAINER=$CONTAINER" >> $GITHUB_ENV

    - name: Add backend.tf
      run: |
        cat > terraform/backend.tf <<EOF
        terraform {
          backend "azurerm" {
            resource_group_name  = "${{ env.TF_VAR_resource_group_name }}"
            storage_account_name = "${{ env.STORAGE }}"
            container_name       = "${{ env.CONTAINER }}"
            key                  = "terraform.tfstate"
          }
        }
        EOF

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.9.0"

    - name: Terraform Init
      run: |
        cd terraform
        terraform init
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_USE_OIDC: true

    - name: Terraform Apply
      run: |
        cd terraform
        terraform apply -auto-approve
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_USE_OIDC: true

    - name: Fetch Terraform Outputs
      id: out
      run: |
        cd terraform
        echo "acr_login_server=$(terraform output -raw acr_login_server)" >> $GITHUB_OUTPUT
        echo "acr_name=$(terraform output -raw acr_name)" >> $GITHUB_OUTPUT
        echo "aks_name=$(terraform output -raw aks_name)" >> $GITHUB_OUTPUT
        echo "resource_group=$(terraform output -raw resource_group)" >> $GITHUB_OUTPUT

####################################################################################
# 2) Stage: Build Docker Image
####################################################################################
  build-image:
    name: 2️⃣ Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: terraform-infra

    permissions:
      id-token: write
      contents: read

    steps:
    - uses: actions/checkout@v4

    - name: Login to Azure (OIDC)
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: ACR Login
      run: |
        az acr login --name ${{ needs.terraform-infra.outputs.acr_name }}

    - name: Build Image
      run: |
        docker build -t ${{ needs.terraform-infra.outputs.acr_login_server }}/product:${{ github.sha }} ./services/product

    - name: Push Image
      run: |
        docker push ${{ needs.terraform-infra.outputs.acr_login_server }}/product:${{ github.sha }}

####################################################################################
# 3) Stage: Configure AKS access
####################################################################################
  aks-setup:
    name: 3️⃣ Configure AKS Access + Attach ACR
    runs-on: ubuntu-latest
    needs: [terraform-infra, build-image]

    steps:
    - uses: actions/checkout@v4

    - name: Login Azure
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Attach ACR to AKS
      run: |
        az aks update \
          --name ${{ needs.terraform-infra.outputs.aks_name }} \
          --resource-group ${{ needs.terraform-infra.outputs.resource_group }} \
          --attach-acr ${{ needs.terraform-infra.outputs.acr_name }}

    - name: Set AKS Context
      uses: azure/aks-set-context@v3
      with:
        cluster-name: ${{ needs.terraform-infra.outputs.aks_name }}
        resource-group: ${{ needs.terraform-infra.outputs.resource_group }}

####################################################################################
# 4) Stage: Deploy App
####################################################################################
  deploy:
    name: 4️⃣ Deploy App to AKS
    runs-on: ubuntu-latest
    needs: [aks-setup]

    steps:
    - uses: actions/checkout@v4

    - name: Apply Namespace
      run: kubectl apply -f k8s/namespace.yaml

    - name: Deploy Product App
      run: |
        sed "s|IMAGE_REPLACED_BY_CI|${{ needs.aks-setup.outputs.acr_login_server }}/product:${{ github.sha }}|" k8s/product-deployment.yaml | kubectl apply -f -

        kubectl apply -f k8s/product-service.yaml
        kubectl apply -f k8s/product-hpa.yaml
        kubectl apply -f k8s/product-pdb.yaml
        kubectl apply -f k8s/ingress.yaml

####################################################################################
# 5) Stage: Verify Deployment
####################################################################################
  verify:
    name: 5️⃣ Verify Deployment
    runs-on: ubuntu-latest
    needs: deploy

    steps:
    - name: Wait for pods
      run: |
        kubectl wait --for=condition=ready pod -l app=product -n ecomm --timeout=300s

    - name: Show resources
      run: |
        kubectl get pods -n ecomm
        kubectl get svc -n ecomm
        kubectl get ingress -n ecomm
