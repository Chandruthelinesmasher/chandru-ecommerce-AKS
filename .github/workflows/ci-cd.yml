name: Full Infra + App Deployment (No Manual Terraform)

on:
  push:
    branches: ["main"]
  workflow_dispatch:  # Allow manual triggering for testing

env:
  TF_VAR_location: "eastus"
  TF_VAR_resource_group_name: "rg-chandru-ecomm"
  TF_VAR_node_vm_size: "Standard_DC2s_v3"
  TF_VAR_node_count: 2
  TF_LOG: INFO

permissions:
  id-token: write
  contents: read

jobs:

  #########################################################
  # STAGE 1 â€” CHECKOUT + LOGIN + BACKEND SETUP
  #########################################################
  setup:
    name: "Stage 1: Checkout & Backend Setup"
    runs-on: ubuntu-latest

    outputs:
      storage: ${{ steps.backend.outputs.storage }}
      container: ${{ steps.backend.outputs.container }}

    steps:
    - name: Checkout Repo
      uses: actions/checkout@v4

    - name: Login to Azure (OIDC)
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Create Terraform Backend
      id: backend
      run: |
        RESOURCE_GROUP=${{ env.TF_VAR_resource_group_name }}
        STORAGE="tfstatechandru"
        CONTAINER="tfstate"

        # Create resource group if it doesn't exist
        if ! az group show -n "$RESOURCE_GROUP" &>/dev/null; then
          echo "Creating resource group $RESOURCE_GROUP..."
          az group create -n "$RESOURCE_GROUP" -l ${{ env.TF_VAR_location }} --tags project=chandru-ecomm
        else
          echo "Resource group $RESOURCE_GROUP already exists"
        fi

        # Create storage account if it doesn't exist
        if ! az storage account show -n "$STORAGE" -g "$RESOURCE_GROUP" &>/dev/null; then
          echo "Creating storage account $STORAGE..."
          az storage account create \
            -n "$STORAGE" \
            -g "$RESOURCE_GROUP" \
            -l ${{ env.TF_VAR_location }} \
            --sku Standard_LRS
        else
          echo "Storage account $STORAGE already exists"
        fi

        # Create container if it doesn't exist
        ACCOUNT_KEY=$(az storage account keys list -g "$RESOURCE_GROUP" -n "$STORAGE" --query '[0].value' -o tsv)
        if ! az storage container show --name "$CONTAINER" --account-name "$STORAGE" --account-key "$ACCOUNT_KEY" &>/dev/null; then
          echo "Creating container $CONTAINER..."
          az storage container create \
            --name "$CONTAINER" \
            --account-name "$STORAGE" \
            --account-key "$ACCOUNT_KEY"
        else
          echo "Container $CONTAINER already exists"
        fi

        echo "storage=$STORAGE" >> $GITHUB_OUTPUT
        echo "container=$CONTAINER" >> $GITHUB_OUTPUT

    - name: Write Backend Config
      run: |
        mkdir -p terraform
        cat > terraform/backend.tf << 'EOF'
        terraform {
          backend "azurerm" {
            resource_group_name  = "${{ env.TF_VAR_resource_group_name }}"
            storage_account_name = "${{ steps.backend.outputs.storage }}"
            container_name       = "${{ steps.backend.outputs.container }}"
            key                  = "terraform.tfstate"
          }
        }
        EOF

    - name: Upload Backend File
      uses: actions/upload-artifact@v4
      with:
        name: backend
        path: terraform/backend.tf



  #########################################################
  # STAGE 2 â€” TERRAFORM INIT + APPLY
  #########################################################
  terraform:
    name: "Stage 2: Terraform Apply Infra"
    needs: setup
    runs-on: ubuntu-latest

    outputs:
      acr_name: ${{ steps.capture.outputs.acr_name }}
      acr_login_server: ${{ steps.capture.outputs.acr_login_server }}
      aks_name: ${{ steps.capture.outputs.aks_name }}
      resource_group: ${{ steps.capture.outputs.resource_group }}

    steps:
    - uses: actions/checkout@v4

    - uses: actions/download-artifact@v4
      with:
        name: backend
        path: terraform/

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.9.0
        terraform_wrapper: false

    - name: Azure Login (OIDC)
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Terraform Init
      run: |
        cd terraform
        terraform init
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_USE_OIDC: true

    - name: Import Existing Resource Group
      run: |
        cd terraform
        if ! terraform state show azurerm_resource_group.rg &>/dev/null; then
          echo "Importing existing resource group into Terraform state..."
          terraform import azurerm_resource_group.rg /subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.TF_VAR_resource_group_name }} || true
        else
          echo "Resource group already in Terraform state"
        fi
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_USE_OIDC: true
      continue-on-error: true

    - name: Terraform Plan
      run: |
        cd terraform
        terraform plan -out=tfplan
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_USE_OIDC: true

    - name: Terraform Apply
      run: |
        cd terraform
        terraform apply -auto-approve tfplan
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_USE_OIDC: true

    - name: Debug - Show Terraform State
      run: |
        cd terraform
        echo "=== Terraform State List ==="
        terraform state list
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_USE_OIDC: true

    - name: Debug - Show All Outputs (JSON)
      run: |
        cd terraform
        echo "=== All Terraform Outputs (JSON) ==="
        terraform output -json | jq .
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_USE_OIDC: true

    - name: Capture Outputs
      id: capture
      run: |
        cd terraform
        
        # Capture with better error handling
        set -e  # Exit on any error
        
        echo "=== Extracting Terraform Outputs ==="
        
        # Use terraform output -json for more reliable parsing
        OUTPUTS=$(terraform output -json)
        
        ACR_NAME=$(echo "$OUTPUTS" | jq -r '.acr_name.value // empty')
        ACR_LOGIN=$(echo "$OUTPUTS" | jq -r '.acr_login_server.value // empty')
        AKS_NAME=$(echo "$OUTPUTS" | jq -r '.aks_name.value // empty')
        RG_NAME=$(echo "$OUTPUTS" | jq -r '.resource_group.value // empty')
        
        echo "Extracted values:"
        echo "  ACR Name: [$ACR_NAME]"
        echo "  ACR Login Server: [$ACR_LOGIN]"
        echo "  AKS Name: [$AKS_NAME]"
        echo "  Resource Group: [$RG_NAME]"
        
        # Validate all outputs are present
        if [ -z "$ACR_NAME" ]; then
          echo "ERROR: acr_name is empty!"
          echo "Full outputs JSON:"
          echo "$OUTPUTS" | jq .
          exit 1
        fi
        
        if [ -z "$ACR_LOGIN" ]; then
          echo "ERROR: acr_login_server is empty!"
          exit 1
        fi
        
        if [ -z "$AKS_NAME" ]; then
          echo "ERROR: aks_name is empty!"
          exit 1
        fi
        
        if [ -z "$RG_NAME" ]; then
          echo "ERROR: resource_group is empty!"
          exit 1
        fi
        
        # Write to GitHub outputs
        {
          echo "acr_name=$ACR_NAME"
          echo "acr_login_server=$ACR_LOGIN"
          echo "aks_name=$AKS_NAME"
          echo "resource_group=$RG_NAME"
        } >> $GITHUB_OUTPUT
        
        echo "=== âœ… All outputs captured successfully ==="
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_USE_OIDC: true

    - name: Verify Outputs Were Set
      run: |
        echo "=== Verifying GitHub Outputs ==="
        echo "ACR Name: ${{ steps.capture.outputs.acr_name }}"
        echo "ACR Login: ${{ steps.capture.outputs.acr_login_server }}"
        echo "AKS Name: ${{ steps.capture.outputs.aks_name }}"
        echo "Resource Group: ${{ steps.capture.outputs.resource_group }}"



  #########################################################
  # STAGE 3 â€” BUILD & PUSH DOCKER IMAGE
  #########################################################
  build:
    name: "Stage 3: Build & Push Docker Image"
    needs: terraform
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Debug - Show Received Outputs
      run: |
        echo "=== Outputs Received from Terraform Job ==="
        echo "ACR Name: [${{ needs.terraform.outputs.acr_name }}]"
        echo "ACR Login Server: [${{ needs.terraform.outputs.acr_login_server }}]"
        echo "AKS Name: [${{ needs.terraform.outputs.aks_name }}]"
        echo "Resource Group: [${{ needs.terraform.outputs.resource_group }}]"

    - name: Validate Outputs
      run: |
        if [ -z "${{ needs.terraform.outputs.acr_name }}" ]; then
          echo "âŒ ERROR: ACR name is empty!"
          exit 1
        fi
        
        if [ -z "${{ needs.terraform.outputs.acr_login_server }}" ]; then
          echo "âŒ ERROR: ACR login server is empty!"
          exit 1
        fi
        
        echo "âœ… All required outputs are present"

    - name: Attach ACR to AKS
      run: |
        echo "Attaching ACR to AKS for image pull permissions..."
        az aks update \
          --name ${{ needs.terraform.outputs.aks_name }} \
          --resource-group ${{ needs.terraform.outputs.resource_group }} \
          --attach-acr ${{ needs.terraform.outputs.acr_name }}

    - name: ACR Login
      run: az acr login --name ${{ needs.terraform.outputs.acr_name }}

    - name: Build & Push Image
      run: |
        IMAGE_TAG="${{ needs.terraform.outputs.acr_login_server }}/product:${{ github.sha }}"
        IMAGE_LATEST="${{ needs.terraform.outputs.acr_login_server }}/product:latest"
        
        echo "=== Building Docker Image ==="
        echo "Image with SHA: $IMAGE_TAG"
        echo "Image latest: $IMAGE_LATEST"
        
        docker build -t "$IMAGE_TAG" ./services/product
        docker tag "$IMAGE_TAG" "$IMAGE_LATEST"
        
        echo "=== Pushing Docker Images ==="
        docker push "$IMAGE_TAG"
        docker push "$IMAGE_LATEST"
        
        echo "âœ… Images pushed successfully"



  #########################################################
  # STAGE 4 â€” DEPLOY TO AKS
  #########################################################
  deploy:
    name: "Stage 4: Deploy to AKS"
    needs: [terraform, build]
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Set AKS Context
      uses: azure/aks-set-context@v3
      with:
        cluster-name: ${{ needs.terraform.outputs.aks_name }}
        resource-group: ${{ needs.terraform.outputs.resource_group }}

    - name: Install Ingress Controller
      run: |
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo update
        helm upgrade --install nginx ingress-nginx/ingress-nginx \
          --namespace ingress-nginx \
          --create-namespace \
          --wait --timeout 5m

    - name: Create Namespace and Secrets
      run: |
        echo "=== Creating Namespace ==="
        kubectl apply -f k8s/namespace.yaml
        
        echo ""
        echo "=== Creating Kubernetes Secrets ==="
        
        # Check if secret already exists
        if kubectl get secret product-secrets -n ecomm &>/dev/null; then
          echo "Secret 'product-secrets' already exists, deleting and recreating..."
          kubectl delete secret product-secrets -n ecomm
        fi
        
        # Create the secret with environment variables
        kubectl create secret generic product-secrets \
          --namespace=ecomm \
          --from-literal=DATABASE_URL="${{ secrets.DATABASE_URL || 'postgresql://user:password@postgres:5432/productdb' }}" \
          --from-literal=REDIS_URL="${{ secrets.REDIS_URL || 'redis://redis:6379' }}" \
          --from-literal=API_KEY="${{ secrets.API_KEY || 'default-api-key' }}" \
          --from-literal=JWT_SECRET="${{ secrets.JWT_SECRET || 'default-jwt-secret' }}"
        
        echo "âœ… Secret created successfully"
        kubectl describe secret product-secrets -n ecomm

    - name: Deploy Application
      run: |
        FULL_IMAGE="${{ needs.terraform.outputs.acr_login_server }}/product:${{ github.sha }}"
        
        echo "=== Deploying Application ==="
        echo "Full image path: $FULL_IMAGE"
        
        # Show the YAML before sed replacement
        echo "=== Original deployment YAML (first 40 lines) ==="
        head -40 k8s/product-deployment.yaml
        
        # Apply the deployment with image replacement
        sed "s|IMAGE_REPLACED_BY_CI|$FULL_IMAGE|g" k8s/product-deployment.yaml | kubectl apply -f -
        
        # Apply other Kubernetes resources
        kubectl apply -f k8s/product-service.yaml
        kubectl apply -f k8s/product-hpa.yaml
        kubectl apply -f k8s/product-pdb.yaml
        kubectl apply -f k8s/ingress.yaml
        
        echo "âœ… Deployment manifests applied successfully"



  #########################################################
  # STAGE 5 â€” VERIFY DEPLOYMENT
  #########################################################
  verify:
    name: "Stage 5: Verify Deployment"
    needs: [terraform, deploy]
    runs-on: ubuntu-latest

    steps:
    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Set AKS Context
      uses: azure/aks-set-context@v3
      with:
        cluster-name: ${{ needs.terraform.outputs.aks_name }}
        resource-group: ${{ needs.terraform.outputs.resource_group }}

    - name: Check Deployment Configuration
      run: |
        echo "=== Deployment Configuration ==="
        kubectl get deployment product -n ecomm -o yaml | grep -A 5 "image:"
        
        echo ""
        echo "=== Deployment Status ==="
        kubectl get deployments -n ecomm
        kubectl describe deployment product -n ecomm

    - name: Check Pod Status
      run: |
        echo "=== Pod Status ==="
        kubectl get pods -n ecomm -l app=product -o wide
        
        echo ""
        echo "=== Pod Details ==="
        kubectl describe pods -n ecomm -l app=product

    - name: Wait for Pods to be Ready
      run: |
        echo "=== Waiting for pods to be ready (timeout: 5 minutes) ==="
        if ! kubectl wait --for=condition=ready pod -l app=product -n ecomm --timeout=300s; then
          echo "âŒ Pods failed to become ready within timeout"
          echo ""
          echo "=== Pod Events ==="
          kubectl get events -n ecomm --sort-by='.lastTimestamp'
          echo ""
          echo "=== Pod Logs ==="
          kubectl logs -n ecomm -l app=product --tail=100 --all-containers=true || true
          exit 1
        fi
        
        echo "âœ… All pods are ready"

    - name: Show Service and Ingress
      run: |
        echo "=== Services ==="
        kubectl get svc -n ecomm
        
        echo ""
        echo "=== Ingress ==="
        kubectl get ingress -n ecomm
        kubectl describe ingress -n ecomm

    - name: Final Status Summary
      run: |
        echo "=== ðŸŽ‰ DEPLOYMENT SUMMARY ==="
        echo ""
        echo "Deployed Image: ${{ needs.terraform.outputs.acr_login_server }}/product:${{ github.sha }}"
        echo ""
        echo "Pods:"
        kubectl get pods -n ecomm -l app=product
        echo ""
        echo "Service:"
        kubectl get svc -n ecomm product
        echo ""
        echo "Ingress:"
        INGRESS_IP=$(kubectl get ingress -n ecomm product-ingress -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
        echo "Ingress IP: $INGRESS_IP"
        if [ "$INGRESS_IP" != "pending" ] && [ -n "$INGRESS_IP" ]; then
          echo "Access your application at: http://$INGRESS_IP"
        else
          echo "Ingress IP is still being assigned. Check back in a few minutes."
        fi