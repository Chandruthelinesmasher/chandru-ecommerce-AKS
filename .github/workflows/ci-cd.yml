name: Full Infra + App Deployment (No Manual Terraform)

on:
  push:
    branches: ["main"]

env:
  TF_VAR_location: "eastus"
  TF_VAR_resource_group_name: "rg-chandru-ecomm"
  TF_VAR_node_vm_size: "Standard_DC2s_v3"
  TF_VAR_node_count: 2
  TF_LOG: INFO

permissions:
  id-token: write
  contents: read

jobs:

  #########################################################
  # STAGE 1 — CHECKOUT + LOGIN + BACKEND SETUP
  #########################################################
  setup:
    name: "Stage 1: Checkout & Backend Setup"
    runs-on: ubuntu-latest

    outputs:
      storage: ${{ steps.backend.outputs.storage }}
      container: ${{ steps.backend.outputs.container }}

    steps:
    - name: Checkout Repo
      uses: actions/checkout@v4

    - name: Login to Azure (OIDC)
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Create Terraform Backend
      id: backend
      run: |
        RESOURCE_GROUP=${{ env.TF_VAR_resource_group_name }}
        # Use a consistent storage account name based on resource group
        STORAGE="tfstatechandru"
        CONTAINER="tfstate"

        # Create resource group if it doesn't exist
        if ! az group show -n "$RESOURCE_GROUP" &>/dev/null; then
          echo "Creating resource group $RESOURCE_GROUP..."
          az group create -n "$RESOURCE_GROUP" -l ${{ env.TF_VAR_location }} --tags project=chandru-ecomm
        else
          echo "Resource group $RESOURCE_GROUP already exists"
        fi

        # Create storage account if it doesn't exist
        if ! az storage account show -n "$STORAGE" -g "$RESOURCE_GROUP" &>/dev/null; then
          echo "Creating storage account $STORAGE..."
          az storage account create \
            -n "$STORAGE" \
            -g "$RESOURCE_GROUP" \
            -l ${{ env.TF_VAR_location }} \
            --sku Standard_LRS
        else
          echo "Storage account $STORAGE already exists"
        fi

        # Create container if it doesn't exist
        ACCOUNT_KEY=$(az storage account keys list -g "$RESOURCE_GROUP" -n "$STORAGE" --query '[0].value' -o tsv)
        if ! az storage container show --name "$CONTAINER" --account-name "$STORAGE" --account-key "$ACCOUNT_KEY" &>/dev/null; then
          echo "Creating container $CONTAINER..."
          az storage container create \
            --name "$CONTAINER" \
            --account-name "$STORAGE" \
            --account-key "$ACCOUNT_KEY"
        else
          echo "Container $CONTAINER already exists"
        fi

        echo "storage=$STORAGE" >> $GITHUB_OUTPUT
        echo "container=$CONTAINER" >> $GITHUB_OUTPUT

    - name: Write Backend Config
      run: |
        mkdir -p terraform
        cat > terraform/backend.tf << 'EOF'
        terraform {
          backend "azurerm" {
            resource_group_name  = "${{ env.TF_VAR_resource_group_name }}"
            storage_account_name = "${{ steps.backend.outputs.storage }}"
            container_name       = "${{ steps.backend.outputs.container }}"
            key                  = "terraform.tfstate"
          }
        }
        EOF

    - name: Upload Backend File
      uses: actions/upload-artifact@v4
      with:
        name: backend
        path: terraform/backend.tf



  #########################################################
  # STAGE 2 — TERRAFORM INIT + APPLY
  #########################################################
  terraform:
    name: "Stage 2: Terraform Apply Infra"
    needs: setup
    runs-on: ubuntu-latest

    outputs:
      acr_name: ${{ steps.capture.outputs.acr_name }}
      acr_login_server: ${{ steps.capture.outputs.acr_login_server }}
      aks_name: ${{ steps.capture.outputs.aks_name }}
      resource_group: ${{ steps.capture.outputs.resource_group }}

    steps:
    - uses: actions/checkout@v4

    - uses: actions/download-artifact@v4
      with:
        name: backend
        path: terraform/

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.9.0
        terraform_wrapper: false

    - name: Azure Login (OIDC)
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Terraform Init
      run: |
        cd terraform
        terraform init
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_USE_OIDC: true

    - name: Import Existing Resource Group
      run: |
        cd terraform
        # Check if resource group exists in state
        if ! terraform state show azurerm_resource_group.rg &>/dev/null; then
          echo "Importing existing resource group into Terraform state..."
          terraform import azurerm_resource_group.rg /subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.TF_VAR_resource_group_name }}
        else
          echo "Resource group already in Terraform state"
        fi
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_USE_OIDC: true
      continue-on-error: true

    - name: Terraform Apply
      run: |
        cd terraform
        terraform apply -auto-approve
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_USE_OIDC: true

    - name: Capture Outputs
      id: capture
      run: |
        cd terraform
        ACR_NAME=$(terraform output -raw acr_name 2>/dev/null || echo "")
        ACR_LOGIN=$(terraform output -raw acr_login_server 2>/dev/null || echo "")
        AKS_NAME=$(terraform output -raw aks_name 2>/dev/null || echo "")
        RG_NAME=$(terraform output -raw resource_group 2>/dev/null || echo "")
        
        echo "Captured values:"
        echo "ACR Name: $ACR_NAME"
        echo "ACR Login Server: $ACR_LOGIN"
        echo "AKS Name: $AKS_NAME"
        echo "Resource Group: $RG_NAME"
        
        if [ -z "$ACR_NAME" ] || [ -z "$ACR_LOGIN" ] || [ -z "$AKS_NAME" ] || [ -z "$RG_NAME" ]; then
          echo "ERROR: One or more Terraform outputs are empty!"
          echo "Available outputs:"
          terraform output
          exit 1
        fi
        
        echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
        echo "acr_login_server=$ACR_LOGIN" >> $GITHUB_OUTPUT
        echo "aks_name=$AKS_NAME" >> $GITHUB_OUTPUT
        echo "resource_group=$RG_NAME" >> $GITHUB_OUTPUT
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_USE_OIDC: true



  #########################################################
  # STAGE 3 — BUILD & PUSH DOCKER IMAGE
  #########################################################
  build:
    name: "Stage 3: Build & Push Docker Image"
    needs: terraform
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Verify ACR Name
      run: |
        if [ -z "${{ needs.terraform.outputs.acr_name }}" ]; then
          echo "ERROR: ACR name is empty!"
          exit 1
        fi
        echo "ACR Name: ${{ needs.terraform.outputs.acr_name }}"
        echo "ACR Login Server: ${{ needs.terraform.outputs.acr_login_server }}"

    - name: Attach ACR to AKS
      run: |
        echo "Attaching ACR to AKS for image pull permissions..."
        az aks update \
          --name ${{ needs.terraform.outputs.aks_name }} \
          --resource-group ${{ needs.terraform.outputs.resource_group }} \
          --attach-acr ${{ needs.terraform.outputs.acr_name }}

    - name: ACR Login
      run: az acr login --name ${{ needs.terraform.outputs.acr_name }}

    - name: Build & Push Image
      run: |
        docker build -t ${{ needs.terraform.outputs.acr_login_server }}/product:${{ github.sha }} ./services/product
        docker push ${{ needs.terraform.outputs.acr_login_server }}/product:${{ github.sha }}



  #########################################################
  # STAGE 4 — DEPLOY TO AKS
  #########################################################
  deploy:
    name: "Stage 4: Deploy to AKS"
    needs: [terraform, build]
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Set AKS Context
      uses: azure/aks-set-context@v3
      with:
        cluster-name: ${{ needs.terraform.outputs.aks_name }}
        resource-group: ${{ needs.terraform.outputs.resource_group }}

    - name: Install Ingress Controller
      run: |
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo update
        helm upgrade --install nginx ingress-nginx/ingress-nginx \
          --namespace ingress-nginx \
          --create-namespace \
          --wait --timeout 5m

    - name: Deploy App
      run: |
        kubectl apply -f k8s/namespace.yaml
        sed "s|IMAGE_REPLACED_BY_CI|${{ needs.terraform.outputs.acr_login_server }}/product:${{ github.sha }}|" \
          k8s/product-deployment.yaml | kubectl apply -f -
        kubectl apply -f k8s/product-service.yaml
        kubectl apply -f k8s/product-hpa.yaml
        kubectl apply -f k8s/product-pdb.yaml
        kubectl apply -f k8s/ingress.yaml



  #########################################################
  # STAGE 5 — VERIFY DEPLOYMENT
  #########################################################
  verify:
    name: "Stage 5: Verify Deployment"
    needs: [terraform, deploy]
    runs-on: ubuntu-latest

    steps:
    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Set AKS Context
      uses: azure/aks-set-context@v3
      with:
        cluster-name: ${{ needs.terraform.outputs.aks_name }}
        resource-group: ${{ needs.terraform.outputs.resource_group }}

    - name: Verify Pods
      run: |
        kubectl wait --for=condition=ready pod -l app=product -n ecomm --timeout=300s || true

    - name: Show Ingress Endpoint
      run: kubectl get ingress -n ecomm